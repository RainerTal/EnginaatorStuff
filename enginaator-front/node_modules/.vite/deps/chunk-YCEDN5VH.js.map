{
  "version": 3,
  "sources": ["../../@zag-js/focus-trap/dist/index.mjs", "../../@zag-js/remove-scroll/dist/index.mjs"],
  "sourcesContent": ["import { getDocument, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, raf, getEventTarget, isDocument, isFocusable, getActiveElement } from '@zag-js/dom-query';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, { subtree: true, childList: true });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        if (this.findContainerIndex(this.doc.activeElement) >= 0) {\n          node = this.doc.activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)\n    );\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      addDomEvent(this.doc, \"focusin\", this.handleFocus, true),\n      addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\nexport { FocusTrap, trapFocus };\n", "import { setStyleProperty, setStyle, isIos } from '@zag-js/dom-query';\n\n// src/index.ts\nvar LOCK_CLASSNAME = \"data-scroll-lock\";\nfunction getPaddingProperty(documentElement) {\n  const documentLeft = documentElement.getBoundingClientRect().left;\n  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n  return scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n}\nfunction preventBodyScroll(_document) {\n  const doc = _document ?? document;\n  const win = doc.defaultView ?? window;\n  const { documentElement, body } = doc;\n  const locked = body.hasAttribute(LOCK_CLASSNAME);\n  if (locked) return;\n  body.setAttribute(LOCK_CLASSNAME, \"\");\n  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n  const setScrollbarWidthProperty = () => setStyleProperty(documentElement, \"--scrollbar-width\", `${scrollbarWidth}px`);\n  const paddingProperty = getPaddingProperty(documentElement);\n  const setBodyStyle = () => setStyle(body, {\n    overflow: \"hidden\",\n    [paddingProperty]: `${scrollbarWidth}px`\n  });\n  const setBodyStyleIOS = () => {\n    const { scrollX, scrollY, visualViewport } = win;\n    const offsetLeft = visualViewport?.offsetLeft ?? 0;\n    const offsetTop = visualViewport?.offsetTop ?? 0;\n    const restoreStyle = setStyle(body, {\n      position: \"fixed\",\n      overflow: \"hidden\",\n      top: `${-(scrollY - Math.floor(offsetTop))}px`,\n      left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n      right: \"0\",\n      [paddingProperty]: `${scrollbarWidth}px`\n    });\n    return () => {\n      restoreStyle?.();\n      win.scrollTo({ left: scrollX, top: scrollY, behavior: \"instant\" });\n    };\n  };\n  const cleanups = [setScrollbarWidthProperty(), isIos() ? setBodyStyleIOS() : setBodyStyle()];\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n    body.removeAttribute(LOCK_CLASSNAME);\n  };\n}\n\nexport { preventBodyScroll };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAEA,IAAI,YAAY,OAAO;AACvB,IAAI,kBAAkB,CAAC,KAAK,KAAK,UAAU,OAAO,MAAM,UAAU,KAAK,KAAK,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,MAAM,CAAC,IAAI,IAAI,GAAG,IAAI;AAC1J,IAAI,gBAAgB,CAAC,KAAK,KAAK,UAAU,gBAAgB,KAAK,OAAO,QAAQ,WAAW,MAAM,KAAK,KAAK,KAAK;AAC7G,IAAI,mBAAmB;AAAA,EACrB,aAAa,WAAW,MAAM;AAC5B,QAAI,UAAU,SAAS,GAAG;AACxB,YAAM,aAAa,UAAU,UAAU,SAAS,CAAC;AACjD,UAAI,eAAe,MAAM;AACvB,mBAAW,MAAM;AAAA,MACnB;AAAA,IACF;AACA,UAAM,YAAY,UAAU,QAAQ,IAAI;AACxC,QAAI,cAAc,IAAI;AACpB,gBAAU,KAAK,IAAI;AAAA,IACrB,OAAO;AACL,gBAAU,OAAO,WAAW,CAAC;AAC7B,gBAAU,KAAK,IAAI;AAAA,IACrB;AAAA,EACF;AAAA,EACA,eAAe,WAAW,MAAM;AAC9B,UAAM,YAAY,UAAU,QAAQ,IAAI;AACxC,QAAI,cAAc,IAAI;AACpB,gBAAU,OAAO,WAAW,CAAC;AAAA,IAC/B;AACA,QAAI,UAAU,SAAS,GAAG;AACxB,gBAAU,UAAU,SAAS,CAAC,EAAE,QAAQ;AAAA,IAC1C;AAAA,EACF;AACF;AACA,IAAI,kBAAkB,CAAC;AACvB,IAAI,YAAY,MAAM;AAAA,EACpB,YAAY,UAAU,SAAS;AAC7B,kBAAc,MAAM,WAAW;AAC/B,kBAAc,MAAM,QAAQ;AAC5B,kBAAc,MAAM,KAAK;AACzB,kBAAc,MAAM,SAAS;AAAA,MAC3B,YAAY,CAAC;AAAA,MACb,iBAAiB,CAAC;AAAA,MAClB,gBAAgB,CAAC;AAAA,MACjB,6BAA6B;AAAA,MAC7B,yBAAyB;AAAA,MACzB,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,wBAAwB;AAAA,MACxB,gBAAgB;AAAA,IAClB,CAAC;AACD,kBAAc,MAAM,oBAAoB,CAAC,CAAC;AAC1C,kBAAc,MAAM,eAAe,CAAC,UAAU;AAC5C,YAAM,SAAS,eAAe,KAAK;AACnC,YAAM,kBAAkB,KAAK,mBAAmB,QAAQ,KAAK,KAAK;AAClE,UAAI,mBAAmB,WAAW,MAAM,GAAG;AACzC,YAAI,iBAAiB;AACnB,eAAK,MAAM,0BAA0B;AAAA,QACvC;AAAA,MACF,OAAO;AACL,cAAM,yBAAyB;AAC/B,YAAI;AACJ,YAAI,sBAAsB;AAC1B,YAAI,KAAK,MAAM,yBAAyB;AACtC,cAAI,YAAY,KAAK,MAAM,uBAAuB,IAAI,GAAG;AACvD,kBAAM,kBAAkB,KAAK,mBAAmB,KAAK,MAAM,uBAAuB;AAClF,kBAAM,EAAE,cAAc,IAAI,KAAK,MAAM,gBAAgB,eAAe;AACpE,gBAAI,cAAc,SAAS,GAAG;AAC5B,oBAAM,YAAY,cAAc,UAAU,CAAC,SAAS,SAAS,KAAK,MAAM,uBAAuB;AAC/F,kBAAI,aAAa,GAAG;AAClB,oBAAI,KAAK,OAAO,aAAa,KAAK,MAAM,cAAc,GAAG;AACvD,sBAAI,YAAY,IAAI,cAAc,QAAQ;AACxC,+BAAW,cAAc,YAAY,CAAC;AACtC,0CAAsB;AAAA,kBACxB;AAAA,gBACF,OAAO;AACL,sBAAI,YAAY,KAAK,GAAG;AACtB,+BAAW,cAAc,YAAY,CAAC;AACtC,0CAAsB;AAAA,kBACxB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF,OAAO;AACL,gBAAI,CAAC,KAAK,MAAM,gBAAgB,KAAK,CAAC,MAAM,EAAE,cAAc,KAAK,CAAC,MAAM,YAAY,CAAC,IAAI,CAAC,CAAC,GAAG;AAC5F,oCAAsB;AAAA,YACxB;AAAA,UACF;AAAA,QACF,OAAO;AACL,gCAAsB;AAAA,QACxB;AACA,YAAI,qBAAqB;AACvB,qBAAW,KAAK,gBAAgB;AAAA;AAAA;AAAA,YAG9B,QAAQ,KAAK,MAAM;AAAA,YACnB,YAAY,KAAK,OAAO,cAAc,KAAK,MAAM,cAAc;AAAA,UACjE,CAAC;AAAA,QACH;AACA,YAAI,UAAU;AACZ,eAAK,SAAS,QAAQ;AAAA,QACxB,OAAO;AACL,eAAK,SAAS,KAAK,MAAM,2BAA2B,KAAK,oBAAoB,CAAC;AAAA,QAChF;AAAA,MACF;AACA,WAAK,MAAM,iBAAiB;AAAA,IAC9B,CAAC;AACD,kBAAc,MAAM,qBAAqB,CAAC,UAAU;AAClD,YAAM,SAAS,eAAe,KAAK;AACnC,UAAI,KAAK,mBAAmB,QAAQ,KAAK,KAAK,GAAG;AAC/C;AAAA,MACF;AACA,UAAI,eAAe,KAAK,OAAO,yBAAyB,KAAK,GAAG;AAC9D,aAAK,WAAW,EAAE,aAAa,KAAK,OAAO,wBAAwB,CAAC;AACpE;AAAA,MACF;AACA,UAAI,eAAe,KAAK,OAAO,mBAAmB,KAAK,GAAG;AACxD;AAAA,MACF;AACA,YAAM,eAAe;AAAA,IACvB,CAAC;AACD,kBAAc,MAAM,eAAe,CAAC,UAAU;AAC5C,YAAM,SAAS,eAAe,KAAK;AACnC,UAAI,KAAK,mBAAmB,QAAQ,KAAK,KAAK,GAAG;AAC/C;AAAA,MACF;AACA,UAAI,eAAe,KAAK,OAAO,yBAAyB,KAAK,GAAG;AAC9D;AAAA,MACF;AACA,UAAI,eAAe,KAAK,OAAO,mBAAmB,KAAK,GAAG;AACxD;AAAA,MACF;AACA,YAAM,eAAe;AACrB,YAAM,yBAAyB;AAAA,IACjC,CAAC;AACD,kBAAc,MAAM,gBAAgB,CAAC,UAAU;AAC7C,UAAI,KAAK,OAAO,aAAa,KAAK,KAAK,KAAK,OAAO,cAAc,KAAK,GAAG;AACvE,aAAK,MAAM,iBAAiB;AAC5B,cAAM,aAAa,KAAK,OAAO,cAAc,KAAK;AAClD,cAAM,kBAAkB,KAAK,gBAAgB,EAAE,OAAO,WAAW,CAAC;AAClE,YAAI,CAAC,gBAAiB;AACtB,YAAI,WAAW,KAAK,GAAG;AACrB,gBAAM,eAAe;AAAA,QACvB;AACA,aAAK,SAAS,eAAe;AAAA,MAC/B;AAAA,IACF,CAAC;AACD,kBAAc,MAAM,mBAAmB,CAAC,UAAU;AAChD,UAAI,cAAc,KAAK,KAAK,eAAe,KAAK,OAAO,mBAAmB,KAAK,MAAM,OAAO;AAC1F,cAAM,eAAe;AACrB,aAAK,WAAW;AAAA,MAClB;AAAA,IACF,CAAC;AACD,kBAAc,MAAM,mBAAmB;AACvC,kBAAc,MAAM,yBAAyB,MAAM;AACjD,YAAM,MAAM,KAAK,IAAI,eAAe;AACpC,WAAK,oBAAoB,IAAI,IAAI,iBAAiB,CAAC,cAAc;AAC/D,cAAM,uBAAuB,UAAU,KAAK,CAAC,aAAa;AACxD,gBAAM,eAAe,MAAM,KAAK,SAAS,YAAY;AACrD,iBAAO,aAAa,KAAK,CAAC,SAAS,SAAS,KAAK,MAAM,uBAAuB;AAAA,QAChF,CAAC;AACD,YAAI,sBAAsB;AACxB,eAAK,SAAS,KAAK,oBAAoB,CAAC;AAAA,QAC1C;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AACD,kBAAc,MAAM,uBAAuB,MAAM;AAnKrD;AAoKM,iBAAK,sBAAL,mBAAwB;AACxB,UAAI,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,QAAQ;AAC3C,aAAK,MAAM,WAAW,IAAI,CAAC,cAAc;AAtKjD,cAAAA;AAuKU,WAAAA,MAAA,KAAK,sBAAL,gBAAAA,IAAwB,QAAQ,WAAW,EAAE,SAAS,MAAM,WAAW,KAAK;AAAA,QAC9E,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,kBAAc,MAAM,uBAAuB,MAAM;AAC/C,UAAI,OAAO,KAAK,iBAAiB,gBAAgB,EAAE,aAAa,KAAK,CAAC;AACtE,UAAI,SAAS,OAAO;AAClB,eAAO;AAAA,MACT;AACA,UAAI,SAAS,UAAU,QAAQ,CAAC,YAAY,IAAI,GAAG;AACjD,YAAI,KAAK,mBAAmB,KAAK,IAAI,aAAa,KAAK,GAAG;AACxD,iBAAO,KAAK,IAAI;AAAA,QAClB,OAAO;AACL,gBAAM,qBAAqB,KAAK,MAAM,eAAe,CAAC;AACtD,gBAAM,oBAAoB,sBAAsB,mBAAmB;AACnE,iBAAO,qBAAqB,KAAK,iBAAiB,eAAe;AAAA,QACnE;AAAA,MACF,WAAW,SAAS,MAAM;AACxB,eAAO,KAAK,iBAAiB,eAAe;AAAA,MAC9C;AACA,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,8DAA8D;AAAA,MAChF;AACA,UAAI,CAAC,KAAK,aAAa;AACrB,eAAO,KAAK,iBAAiB,eAAe;AAAA,MAC9C;AACA,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,YAAY,CAAC,SAAS;AACxC,UAAI,SAAS,MAAO;AACpB,UAAI,SAAS,iBAAiB,KAAK,GAAG,EAAG;AACzC,UAAI,CAAC,QAAQ,CAAC,KAAK,OAAO;AACxB,aAAK,SAAS,KAAK,oBAAoB,CAAC;AACxC;AAAA,MACF;AACA,WAAK,MAAM,EAAE,eAAe,CAAC,CAAC,KAAK,OAAO,cAAc,CAAC;AACzD,WAAK,MAAM,0BAA0B;AACrC,UAAI,kBAAkB,IAAI,GAAG;AAC3B,aAAK,OAAO;AAAA,MACd;AAAA,IACF,CAAC;AACD,kBAAc,MAAM,cAAc,CAAC,sBAAsB;AACvD,UAAI,CAAC,KAAK,MAAM,OAAQ,QAAO;AAC/B,YAAMC,WAAU;AAAA,QACd,cAAc,KAAK,OAAO;AAAA,QAC1B,kBAAkB,KAAK,OAAO;AAAA,QAC9B,qBAAqB,KAAK,OAAO;AAAA,QACjC,GAAG;AAAA,MACL;AACA,mBAAa,KAAK,MAAM,sBAAsB;AAC9C,WAAK,MAAM,yBAAyB;AACpC,WAAK,gBAAgB;AACrB,WAAK,MAAM,SAAS;AACpB,WAAK,MAAM,SAAS;AACpB,WAAK,oBAAoB;AACzB,uBAAiB,eAAe,KAAK,WAAW,IAAI;AACpD,YAAM,eAAe,KAAK,UAAUA,UAAS,cAAc;AAC3D,YAAM,mBAAmB,KAAK,UAAUA,UAAS,kBAAkB;AACnE,YAAM,sBAAsB,KAAK,UAAUA,UAAS,qBAAqB;AACzE,YAAM,cAAc,KAAK,UAAUA,UAAS,eAAe,yBAAyB;AACpF;AACA,YAAM,qBAAqB,MAAM;AAC/B,cAAM,MAAM;AACV,cAAI,aAAa;AACf,kBAAM,kBAAkB,KAAK,mBAAmB,KAAK,MAAM,2BAA2B;AACtF,iBAAK,SAAS,eAAe;AAAA,UAC/B;AACA;AAAA,QACF,CAAC;AAAA,MACH;AACA,UAAI,eAAe,qBAAqB;AACtC,cAAM,kBAAkB,KAAK,mBAAmB,KAAK,MAAM,2BAA2B;AACtF,4BAAoB,eAAe,EAAE,KAAK,oBAAoB,kBAAkB;AAChF,eAAO;AAAA,MACT;AACA,yBAAmB;AACnB,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,SAAS,CAAC,iBAAiB;AAC7C,UAAI,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,QAAQ;AAC3C,eAAO;AAAA,MACT;AACA,YAAM,UAAU,KAAK,UAAU,cAAc,SAAS;AACtD,YAAM,cAAc,KAAK,UAAU,cAAc,aAAa;AAC9D,WAAK,MAAM,SAAS;AACpB;AACA,WAAK,gBAAgB;AACrB,WAAK,oBAAoB;AACzB;AACA,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,WAAW,CAAC,mBAAmB;AACjD,UAAI,CAAC,KAAK,MAAM,UAAU,CAAC,KAAK,MAAM,QAAQ;AAC5C,eAAO;AAAA,MACT;AACA,YAAM,YAAY,KAAK,UAAU,gBAAgB,WAAW;AAC5D,YAAM,gBAAgB,KAAK,UAAU,gBAAgB,eAAe;AACpE,WAAK,MAAM,SAAS;AACpB;AACA,WAAK,oBAAoB;AACzB,WAAK,aAAa;AAClB,WAAK,oBAAoB;AACzB;AACA,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,2BAA2B,CAAC,sBAAsB;AACpE,WAAK,MAAM,aAAa,MAAM,QAAQ,iBAAiB,IAAI,kBAAkB,OAAO,OAAO,IAAI,CAAC,iBAAiB,EAAE,OAAO,OAAO;AACjI,UAAI,KAAK,MAAM,QAAQ;AACrB,aAAK,oBAAoB;AAAA,MAC3B;AACA,WAAK,oBAAoB;AACzB,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,sBAAsB,CAAC,0BAA0B;AACnE,YAAM,OAAO,KAAK,iBAAiB,kBAAkB;AAAA,QACnD,QAAQ,CAAC,qBAAqB;AAAA,MAChC,CAAC;AACD,aAAO,OAAO,OAAO,SAAS,QAAQ,QAAQ;AAAA,IAChD,CAAC;AACD,kBAAc,MAAM,aAAa,CAAC,uBAAuB,YAAY,qBAAqB;AACxF,aAAO,yBAAyB,sBAAsB,UAAU,MAAM,SAAS,sBAAsB,UAAU;AAAA;AAAA,QAE7G,KAAK,OAAO,oBAAoB,UAAU;AAAA;AAAA,IAE9C,CAAC;AACD,kBAAc,MAAM,oBAAoB,CAAC,YAAY,EAAE,cAAc,OAAO,SAAS,CAAC,EAAE,IAAI,CAAC,MAAM;AACjG,UAAI,cAAc,KAAK,OAAO,UAAU;AACxC,UAAI,OAAO,gBAAgB,WAAY,eAAc,YAAY,GAAG,MAAM;AAC1E,UAAI,gBAAgB,KAAM,eAAc;AACxC,UAAI,CAAC,aAAa;AAChB,YAAI,gBAAgB,UAAU,gBAAgB,OAAO;AACnD,iBAAO;AAAA,QACT;AACA,cAAM,IAAI,MAAM,KAAK,UAAU,+DAA+D;AAAA,MAChG;AACA,UAAI,OAAO;AACX,UAAI,OAAO,gBAAgB,UAAU;AACnC,YAAI;AACF,iBAAO,KAAK,IAAI,cAAc,WAAW;AAAA,QAC3C,SAAS,KAAK;AACZ,gBAAM,IAAI,MAAM,KAAK,UAAU,gDAAgD,IAAI,OAAO,GAAG;AAAA,QAC/F;AACA,YAAI,CAAC,MAAM;AACT,cAAI,CAAC,aAAa;AAChB,kBAAM,IAAI,MAAM,KAAK,UAAU,wCAAwC;AAAA,UACzE;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AACD,kBAAc,MAAM,mBAAmB,CAAC,SAAS;AAC/C,YAAM,EAAE,OAAO,aAAa,MAAM,IAAI;AACtC,YAAM,SAAS,KAAK,UAAU,eAAe,KAAK;AAClD,WAAK,oBAAoB;AACzB,UAAI,kBAAkB;AACtB,UAAI,KAAK,MAAM,eAAe,SAAS,GAAG;AACxC,cAAM,iBAAiB,KAAK,mBAAmB,QAAQ,KAAK;AAC5D,cAAM,iBAAiB,kBAAkB,IAAI,KAAK,MAAM,gBAAgB,cAAc,IAAI;AAC1F,YAAI,iBAAiB,GAAG;AACtB,cAAI,YAAY;AACd,8BAAkB,KAAK,MAAM,eAAe,KAAK,MAAM,eAAe,SAAS,CAAC,EAAE;AAAA,UACpF,OAAO;AACL,8BAAkB,KAAK,MAAM,eAAe,CAAC,EAAE;AAAA,UACjD;AAAA,QACF,WAAW,YAAY;AACrB,cAAI,oBAAoB,KAAK,MAAM,eAAe;AAAA,YAChD,CAAC,EAAE,kBAAkB,MAAM,WAAW;AAAA,UACxC;AACA,cAAI,oBAAoB,OAAM,iDAAgB,eAAc,UAAU,YAAY,MAAM,KAAK,CAAC,WAAW,MAAM,KAAK,EAAC,iDAAgB,iBAAiB,QAAQ,UAAS;AACrK,gCAAoB;AAAA,UACtB;AACA,cAAI,qBAAqB,GAAG;AAC1B,kBAAM,wBAAwB,sBAAsB,IAAI,KAAK,MAAM,eAAe,SAAS,IAAI,oBAAoB;AACnH,kBAAM,mBAAmB,KAAK,MAAM,eAAe,qBAAqB;AACxE,8BAAkB,YAAY,MAAM,KAAK,IAAI,iBAAiB,mBAAmB,iBAAiB;AAAA,UACpG,WAAW,CAAC,WAAW,KAAK,GAAG;AAC7B,8BAAkB,iDAAgB,iBAAiB,QAAQ;AAAA,UAC7D;AAAA,QACF,OAAO;AACL,cAAI,mBAAmB,KAAK,MAAM,eAAe;AAAA,YAC/C,CAAC,EAAE,iBAAiB,MAAM,WAAW;AAAA,UACvC;AACA,cAAI,mBAAmB,OAAM,iDAAgB,eAAc,UAAU,YAAY,MAAM,KAAK,CAAC,WAAW,MAAM,KAAK,EAAC,iDAAgB,iBAAiB,WAAU;AAC7J,+BAAmB;AAAA,UACrB;AACA,cAAI,oBAAoB,GAAG;AACzB,kBAAM,wBAAwB,qBAAqB,KAAK,MAAM,eAAe,SAAS,IAAI,IAAI,mBAAmB;AACjH,kBAAM,mBAAmB,KAAK,MAAM,eAAe,qBAAqB;AACxE,8BAAkB,YAAY,MAAM,KAAK,IAAI,iBAAiB,oBAAoB,iBAAiB;AAAA,UACrG,WAAW,CAAC,WAAW,KAAK,GAAG;AAC7B,8BAAkB,iDAAgB,iBAAiB;AAAA,UACrD;AAAA,QACF;AAAA,MACF,OAAO;AACL,0BAAkB,KAAK,iBAAiB,eAAe;AAAA,MACzD;AACA,aAAO;AAAA,IACT,CAAC;AACD,SAAK,YAAY,QAAQ,aAAa;AACtC,UAAM,SAAS;AAAA,MACb,yBAAyB;AAAA,MACzB,mBAAmB;AAAA,MACnB,mBAAmB;AAAA,MACnB,aAAa,GAAG;AACd,eAAO,WAAW,CAAC,KAAK,CAAC,EAAE;AAAA,MAC7B;AAAA,MACA,cAAc,GAAG;AACf,eAAO,WAAW,CAAC,KAAK,EAAE;AAAA,MAC5B;AAAA,MACA,GAAG;AAAA,IACL;AACA,SAAK,MAAM,OAAO,YAAY,YAAY,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI,QAAQ;AAC1F,SAAK,SAAS;AACd,SAAK,wBAAwB,QAAQ;AACrC,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EACA,mBAAmB,SAAS,OAAO;AACjC,UAAM,eAAe,QAAO,+BAAO,kBAAiB,aAAa,MAAM,aAAa,IAAI;AACxF,WAAO,KAAK,MAAM,gBAAgB;AAAA,MAChC,CAAC,EAAE,WAAW,cAAc,MAAM,UAAU,SAAS,OAAO,MAAK,6CAAc,SAAS,eAAc,cAAc,KAAK,CAAC,SAAS,SAAS,OAAO;AAAA,IACrJ;AAAA,EACF;AAAA,EACA,sBAAsB;AACpB,SAAK,MAAM,kBAAkB,KAAK,MAAM,WAAW,IAAI,CAAC,cAAc;AACpE,YAAM,gBAAgB,aAAa,SAAS;AAC5C,YAAM,iBAAiB,cAAc,SAAS;AAC9C,YAAM,oBAAoB,cAAc,SAAS,IAAI,cAAc,CAAC,IAAI;AACxE,YAAM,mBAAmB,cAAc,SAAS,IAAI,cAAc,cAAc,SAAS,CAAC,IAAI;AAC9F,YAAM,uBAAuB,eAAe,KAAK,CAAC,SAAS,WAAW,IAAI,CAAC;AAC3E,YAAM,sBAAsB,eAAe,MAAM,EAAE,QAAQ,EAAE,KAAK,CAAC,SAAS,WAAW,IAAI,CAAC;AAC5F,YAAM,qBAAqB,CAAC,CAAC,cAAc,KAAK,CAAC,SAAS,YAAY,IAAI,IAAI,CAAC;AAC/E,eAAS,iBAAiB,MAAM,UAAU,MAAM;AAC9C,cAAM,UAAU,cAAc,QAAQ,IAAI;AAC1C,YAAI,UAAU,GAAG;AACf,cAAI,SAAS;AACX,mBAAO,eAAe,MAAM,eAAe,QAAQ,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,OAAO,WAAW,EAAE,CAAC;AAAA,UAC3F;AACA,iBAAO,eAAe,MAAM,GAAG,eAAe,QAAQ,IAAI,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,OAAO,WAAW,EAAE,CAAC;AAAA,QACpG;AACA,eAAO,cAAc,WAAW,UAAU,IAAI,GAAG;AAAA,MACnD;AACA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AACD,SAAK,MAAM,iBAAiB,KAAK,MAAM,gBAAgB,OAAO,CAAC,UAAU,MAAM,cAAc,SAAS,CAAC;AACvG,QAAI,KAAK,MAAM,eAAe,UAAU,KAAK,CAAC,KAAK,iBAAiB,eAAe,GAAG;AACpF,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,QAAI,KAAK,MAAM,gBAAgB,KAAK,CAAC,MAAM,EAAE,kBAAkB,KAAK,KAAK,MAAM,gBAAgB,SAAS,GAAG;AACzG,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,eAAe;AACb,QAAI,CAAC,KAAK,MAAM,OAAQ;AACxB,qBAAiB,aAAa,KAAK,WAAW,IAAI;AAClD,SAAK,MAAM,yBAAyB,KAAK,OAAO,oBAAoB,MAAM,MAAM;AAC9E,WAAK,SAAS,KAAK,oBAAoB,CAAC;AAAA,IAC1C,CAAC,IAAI,KAAK,SAAS,KAAK,oBAAoB,CAAC;AAC7C,SAAK,iBAAiB;AAAA,MACpB,YAAY,KAAK,KAAK,WAAW,KAAK,aAAa,IAAI;AAAA,MACvD,YAAY,KAAK,KAAK,aAAa,KAAK,mBAAmB,EAAE,SAAS,MAAM,SAAS,MAAM,CAAC;AAAA,MAC5F,YAAY,KAAK,KAAK,cAAc,KAAK,mBAAmB,EAAE,SAAS,MAAM,SAAS,MAAM,CAAC;AAAA,MAC7F,YAAY,KAAK,KAAK,SAAS,KAAK,aAAa,EAAE,SAAS,MAAM,SAAS,MAAM,CAAC;AAAA,MAClF,YAAY,KAAK,KAAK,WAAW,KAAK,cAAc,EAAE,SAAS,MAAM,SAAS,MAAM,CAAC;AAAA,MACrF,YAAY,KAAK,KAAK,WAAW,KAAK,eAAe;AAAA,IACvD;AACA,WAAO;AAAA,EACT;AAAA,EACA,kBAAkB;AAChB,QAAI,CAAC,KAAK,MAAM,OAAQ;AACxB,SAAK,iBAAiB,QAAQ,CAAC,YAAY,QAAQ,CAAC;AACpD,SAAK,mBAAmB,CAAC;AACzB,WAAO;AAAA,EACT;AAAA,EACA,SAAS,iBAAiB;AACxB,QAAI,KAAK,MAAM,QAAQ;AACrB,aAAO;AAAA,IACT;AACA,UAAM,aAAa,KAAK,UAAU,iBAAiB,YAAY;AAC/D,UAAM,iBAAiB,KAAK,UAAU,iBAAiB,gBAAgB;AACvE,UAAM,oBAAoB,KAAK,UAAU,iBAAiB,mBAAmB;AAC7E,QAAI,CAAC,mBAAmB;AACtB,WAAK,oBAAoB;AAAA,IAC3B;AACA,SAAK,MAAM,SAAS;AACpB,SAAK,MAAM,SAAS;AACpB,SAAK,MAAM,8BAA8B,KAAK,IAAI,iBAAiB;AACnE;AACA,UAAM,mBAAmB,MAAM;AAC7B,UAAI,mBAAmB;AACrB,aAAK,oBAAoB;AAAA,MAC3B;AACA,WAAK,aAAa;AAClB,WAAK,oBAAoB;AACzB;AAAA,IACF;AACA,QAAI,mBAAmB;AACrB,wBAAkB,KAAK,MAAM,WAAW,OAAO,CAAC,EAAE,KAAK,kBAAkB,gBAAgB;AACzF,aAAO;AAAA,IACT;AACA,qBAAiB;AACjB,WAAO;AAAA,EACT;AACF;AACA,IAAI,aAAa,CAAC,UAAU,MAAM,QAAQ;AAC1C,IAAI,iBAAiB,CAAC,UAAU,WAAW,OAAO,UAAU,aAAa,MAAM,GAAG,MAAM,IAAI;AAC5F,IAAI,gBAAgB,CAAC,UAAU,CAAC,MAAM,eAAe,MAAM,QAAQ;AACnE,IAAI,QAAQ,CAAC,OAAO,WAAW,IAAI,CAAC;AACpC,IAAI,oBAAoB,CAAC,SAAS,KAAK,cAAc,WAAW,YAAY,QAAQ,OAAO,KAAK,WAAW;AAG3G,SAAS,UAAU,IAAI,UAAU,CAAC,GAAG;AACnC,MAAI;AACJ,QAAM,UAAU,IAAI,MAAM;AACxB,UAAM,YAAY,OAAO,OAAO,aAAa,GAAG,IAAI;AACpD,QAAI,CAAC,UAAW;AAChB,WAAO,IAAI,UAAU,WAAW;AAAA,MAC9B,mBAAmB;AAAA,MACnB,mBAAmB;AAAA,MACnB,eAAe;AAAA,MACf,yBAAyB;AAAA,MACzB,mBAAmB;AAAA,MACnB,eAAe;AAAA,MACf,GAAG;AAAA,MACH,UAAU,YAAY,SAAS;AAAA,IACjC,CAAC;AACD,QAAI;AACF,WAAK,SAAS;AAAA,IAChB,QAAQ;AAAA,IACR;AAAA,EACF,CAAC;AACD,SAAO,SAAS,UAAU;AACxB,iCAAM;AACN,YAAQ;AAAA,EACV;AACF;;;ACtgBA,IAAI,iBAAiB;AACrB,SAAS,mBAAmB,iBAAiB;AAC3C,QAAM,eAAe,gBAAgB,sBAAsB,EAAE;AAC7D,QAAM,aAAa,KAAK,MAAM,YAAY,IAAI,gBAAgB;AAC9D,SAAO,aAAa,gBAAgB;AACtC;AACA,SAAS,kBAAkB,WAAW;AACpC,QAAM,MAAM,aAAa;AACzB,QAAM,MAAM,IAAI,eAAe;AAC/B,QAAM,EAAE,iBAAiB,KAAK,IAAI;AAClC,QAAM,SAAS,KAAK,aAAa,cAAc;AAC/C,MAAI,OAAQ;AACZ,OAAK,aAAa,gBAAgB,EAAE;AACpC,QAAM,iBAAiB,IAAI,aAAa,gBAAgB;AACxD,QAAM,4BAA4B,MAAM,iBAAiB,iBAAiB,qBAAqB,GAAG,cAAc,IAAI;AACpH,QAAM,kBAAkB,mBAAmB,eAAe;AAC1D,QAAM,eAAe,MAAM,SAAS,MAAM;AAAA,IACxC,UAAU;AAAA,IACV,CAAC,eAAe,GAAG,GAAG,cAAc;AAAA,EACtC,CAAC;AACD,QAAM,kBAAkB,MAAM;AAC5B,UAAM,EAAE,SAAS,SAAS,eAAe,IAAI;AAC7C,UAAM,cAAa,iDAAgB,eAAc;AACjD,UAAM,aAAY,iDAAgB,cAAa;AAC/C,UAAM,eAAe,SAAS,MAAM;AAAA,MAClC,UAAU;AAAA,MACV,UAAU;AAAA,MACV,KAAK,GAAG,EAAE,UAAU,KAAK,MAAM,SAAS,EAAE;AAAA,MAC1C,MAAM,GAAG,EAAE,UAAU,KAAK,MAAM,UAAU,EAAE;AAAA,MAC5C,OAAO;AAAA,MACP,CAAC,eAAe,GAAG,GAAG,cAAc;AAAA,IACtC,CAAC;AACD,WAAO,MAAM;AACX;AACA,UAAI,SAAS,EAAE,MAAM,SAAS,KAAK,SAAS,UAAU,UAAU,CAAC;AAAA,IACnE;AAAA,EACF;AACA,QAAM,WAAW,CAAC,0BAA0B,GAAG,MAAM,IAAI,gBAAgB,IAAI,aAAa,CAAC;AAC3F,SAAO,MAAM;AACX,aAAS,QAAQ,CAAC,OAAO,0BAAM;AAC/B,SAAK,gBAAgB,cAAc;AAAA,EACrC;AACF;",
  "names": ["_a", "options"]
}
