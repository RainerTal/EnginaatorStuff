{
  "version": 3,
  "sources": ["../../proxy-compare/dist/index.js", "../../@zag-js/store/dist/index.mjs", "../../@zag-js/tooltip/dist/index.mjs"],
  "sourcesContent": ["/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nexport const isChanged = (prevObj, nextObj, affected, cache, // for object with cycles\nisEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit === nextObj) {\n            return false;\n        }\n        // for object with cycles\n        cache.set(prevObj, nextObj);\n    }\n    let changed = null;\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n        changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n        if (changed)\n            return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        changed = isAllOwnKeysChanged(prevObj, nextObj);\n        if (changed)\n            return changed;\n    }\n    else {\n        for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n            const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n            const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n            changed = hasPrev !== hasNext;\n            if (changed)\n                return changed;\n        }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n        changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n        if (changed)\n            return changed;\n    }\n    if (changed === null)\n        throw new Error('invalid used');\n    return changed;\n};\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n", "import { markToTrack, getUntracked } from 'proxy-compare';\n\n// src/global.ts\nfunction glob() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction globalRef(key, value) {\n  const g = glob();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\nvar refSet = globalRef(\"__zag__refSet\", () => /* @__PURE__ */ new WeakSet());\n\n// src/utils.ts\nvar isReactElement = (x) => typeof x === \"object\" && x !== null && \"$$typeof\" in x && \"props\" in x;\nvar isVueElement = (x) => typeof x === \"object\" && x !== null && \"__v_isVNode\" in x;\nvar isDOMElement = (x) => typeof x === \"object\" && x !== null && \"nodeType\" in x && typeof x.nodeName === \"string\";\nvar isElement = (x) => isReactElement(x) || isVueElement(x) || isDOMElement(x);\nvar isObject = (x) => x !== null && typeof x === \"object\";\nvar canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nvar isDev = () => process.env.NODE_ENV !== \"production\";\n\n// src/clone.ts\nfunction set(obj, key, val) {\n  if (typeof val.value === \"object\" && !canProxy(val.value)) val.value = clone(val.value);\n  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === \"__proto__\") {\n    Object.defineProperty(obj, key, val);\n  } else obj[key] = val.value;\n}\nfunction clone(x) {\n  if (typeof x !== \"object\") return x;\n  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);\n  if (str === \"[object Object]\") {\n    tmp = Object.create(Object.getPrototypeOf(x) || null);\n  } else if (str === \"[object Array]\") {\n    tmp = Array(x.length);\n  } else if (str === \"[object Set]\") {\n    tmp = /* @__PURE__ */ new Set();\n    x.forEach(function(val) {\n      tmp.add(clone(val));\n    });\n  } else if (str === \"[object Map]\") {\n    tmp = /* @__PURE__ */ new Map();\n    x.forEach(function(val, key) {\n      tmp.set(clone(key), clone(val));\n    });\n  } else if (str === \"[object Date]\") {\n    tmp = /* @__PURE__ */ new Date(+x);\n  } else if (str === \"[object RegExp]\") {\n    tmp = new RegExp(x.source, x.flags);\n  } else if (str === \"[object DataView]\") {\n    tmp = new x.constructor(clone(x.buffer));\n  } else if (str === \"[object ArrayBuffer]\") {\n    tmp = x.slice(0);\n  } else if (str === \"[object Blob]\") {\n    tmp = x.slice();\n  } else if (str.slice(-6) === \"Array]\") {\n    tmp = new x.constructor(x);\n  }\n  if (tmp) {\n    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {\n      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n    }\n    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {\n      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;\n      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n    }\n  }\n  return tmp || x;\n}\nvar proxyStateMap = globalRef(\"__zag__proxyStateMap\", () => /* @__PURE__ */ new WeakMap());\nvar buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version) => {\n  const cache = snapCache.get(target);\n  if (cache?.[0] === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n      snap[key] = value;\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (isDev() && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      entry[1]?.();\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (isDev() && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = getUntracked(value) || value;\n      }\n      let nextValue = value;\n      if (Object.getOwnPropertyDescriptor(target, prop)?.set) ; else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const { get, set: set2 } = typeof computedFn === \"function\" ? { get: computedFn } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set2) {\n      desc.set = (newValue) => set2(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\n\nexport { clone, globalRef, proxy, proxyWithComputed, ref, snapshot, subscribe };\n", "import { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, getOverflowAncestors, isComposingEvent, dataAttr } from '@zag-js/dom-query';\nimport { trackFocusVisible, isFocusVisible } from '@zag-js/focus-visible';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { proxy, subscribe } from '@zag-js/store';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/tooltip.anatomy.ts\nvar anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/tooltip.dom.ts\nvar getTriggerId = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;\nvar getContentId = (scope) => scope.ids?.content ?? `tooltip:${scope.id}:content`;\nvar getArrowId = (scope) => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;\nvar getPositionerId = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;\nvar getTriggerEl = (scope) => scope.getById(getTriggerId(scope));\nvar getPositionerEl = (scope) => scope.getById(getPositionerId(scope));\nvar store = proxy({ id: null });\n\n// src/tooltip.connect.ts\nfunction connect(service, normalize) {\n  const { state, context, send, scope, prop, event: _event } = service;\n  const id = prop(\"id\");\n  const hasAriaLabel = !!prop(\"aria-label\");\n  const open = state.matches(\"open\", \"closing\");\n  const triggerId = getTriggerId(scope);\n  const contentId = getContentId(scope);\n  const disabled = prop(\"disabled\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: context.get(\"currentPlacement\")\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\", \"closing\");\n      if (open2 === nextOpen) return;\n      send({ type: nextOpen ? \"open\" : \"close\" });\n    },\n    reposition(options = {}) {\n      send({ type: \"positioning.set\", options });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: triggerId,\n        dir: prop(\"dir\"),\n        \"data-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnClick\")) return;\n          send({ type: \"close\", src: \"trigger.click\" });\n        },\n        onFocus(event) {\n          queueMicrotask(() => {\n            if (event.defaultPrevented) return;\n            if (disabled) return;\n            if (_event.src === \"trigger.pointerdown\") return;\n            if (!isFocusVisible()) return;\n            send({ type: \"open\", src: \"trigger.focus\" });\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.id) {\n            send({ type: \"close\", src: \"trigger.blur\" });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnPointerDown\")) return;\n          if (id === store.id) {\n            send({ type: \"close\", src: \"trigger.pointerdown\" });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send({ type: \"pointer.move\" });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({ type: \"pointer.leave\" });\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send({ type: \"pointer.leave\" });\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: getPositionerId(scope),\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": context.get(\"currentPlacement\"),\n        onPointerEnter() {\n          send({ type: \"content.pointer.move\" });\n        },\n        onPointerLeave() {\n          send({ type: \"content.pointer.leave\" });\n        },\n        style: {\n          pointerEvents: prop(\"interactive\") ? \"auto\" : \"none\"\n        }\n      });\n    }\n  };\n}\nvar { and, not } = createGuards();\nvar machine = createMachine({\n  initialState: ({ prop }) => {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  props({ props: props2 }) {\n    return {\n      id: \"x\",\n      openDelay: 1e3,\n      closeDelay: 500,\n      closeOnPointerDown: true,\n      closeOnEscape: true,\n      interactive: false,\n      closeOnScroll: true,\n      closeOnClick: true,\n      disabled: false,\n      ...props2,\n      positioning: {\n        placement: \"bottom\",\n        ...props2.positioning\n      }\n    };\n  },\n  effects: [\"trackFocusVisible\", \"trackStore\"],\n  context: ({ bindable }) => ({\n    currentPlacement: bindable(() => ({ defaultValue: void 0 })),\n    hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))\n  }),\n  watch({ track, action, prop }) {\n    track([() => prop(\"disabled\")], () => {\n      action([\"closeIfDisabled\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  states: {\n    closed: {\n      entry: [\"clearGlobalId\"],\n      on: {\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        ],\n        \"pointer.leave\": {\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        \"pointer.move\": [\n          {\n            guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n            target: \"opening\"\n          },\n          {\n            guard: not(\"hasPointerMoveOpened\"),\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ]\n      }\n    },\n    opening: {\n      effects: [\"trackScroll\", \"trackPointerlockChange\", \"waitForOpenDelay\"],\n      on: {\n        \"after.openDelay\": [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ],\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        open: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"invokeOnOpen\"]\n          }\n        ],\n        \"pointer.leave\": [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\", \"toggleVisibility\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }\n        ],\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"invokeOnClose\", \"toggleVisibility\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ]\n      }\n    },\n    open: {\n      effects: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n      entry: [\"setGlobalId\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"pointer.leave\": [\n          {\n            guard: \"isVisible\",\n            target: \"closing\",\n            actions: [\"clearPointerMoveOpened\"]\n          },\n          // == group ==\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n          }\n        ],\n        \"content.pointer.leave\": {\n          guard: \"isInteractive\",\n          target: \"closing\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    },\n    closing: {\n      effects: [\"trackPositioning\", \"waitForCloseDelay\"],\n      on: {\n        \"after.closeDelay\": [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        close: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnClose\"]\n          },\n          {\n            target: \"closed\",\n            actions: [\"invokeOnClose\"]\n          }\n        ],\n        \"pointer.move\": [\n          {\n            guard: \"isOpenControlled\",\n            // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\", \"toggleVisibility\"]\n          },\n          {\n            target: \"open\",\n            actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n          }\n        ],\n        \"content.pointer.move\": {\n          guard: \"isInteractive\",\n          target: \"open\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      noVisibleTooltip: () => store.id === null,\n      isVisible: ({ prop }) => prop(\"id\") === store.id,\n      isInteractive: ({ prop }) => !!prop(\"interactive\"),\n      hasPointerMoveOpened: ({ context }) => context.get(\"hasPointerMoveOpened\"),\n      isOpenControlled: ({ prop }) => prop(\"open\") !== void 0\n    },\n    actions: {\n      setGlobalId: ({ prop }) => {\n        store.id = prop(\"id\");\n      },\n      clearGlobalId: ({ prop }) => {\n        if (prop(\"id\") === store.id) {\n          store.id = null;\n        }\n      },\n      invokeOnOpen: ({ prop }) => {\n        prop(\"onOpenChange\")?.({ open: true });\n      },\n      invokeOnClose: ({ prop }) => {\n        prop(\"onOpenChange\")?.({ open: false });\n      },\n      closeIfDisabled: ({ prop, send }) => {\n        if (!prop(\"disabled\")) return;\n        send({ type: \"close\", src: \"disabled.change\" });\n      },\n      reposition: ({ context, event, prop, scope }) => {\n        if (event.type !== \"positioning.set\") return;\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility: ({ prop, event, send }) => {\n        queueMicrotask(() => {\n          send({\n            type: prop(\"open\") ? \"controlled.open\" : \"controlled.close\",\n            previousEvent: event\n          });\n        });\n      },\n      setPointerMoveOpened: ({ context }) => {\n        context.set(\"hasPointerMoveOpened\", true);\n      },\n      clearPointerMoveOpened: ({ context }) => {\n        context.set(\"hasPointerMoveOpened\", false);\n      }\n    },\n    effects: {\n      trackFocusVisible: ({ scope }) => {\n        return trackFocusVisible({ root: scope.getRootNode?.() });\n      },\n      trackPositioning: ({ context, prop, scope }) => {\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackPointerlockChange: ({ send, scope }) => {\n        const doc = scope.getDoc();\n        const onChange = () => send({ type: \"close\", src: \"pointerlock:change\" });\n        return addDomEvent(doc, \"pointerlockchange\", onChange, false);\n      },\n      trackScroll: ({ send, prop, scope }) => {\n        if (!prop(\"closeOnScroll\")) return;\n        const triggerEl = getTriggerEl(scope);\n        if (!triggerEl) return;\n        const overflowParents = getOverflowAncestors(triggerEl);\n        const cleanups = overflowParents.map((overflowParent) => {\n          const onScroll = () => {\n            send({ type: \"close\", src: \"scroll\" });\n          };\n          return addDomEvent(overflowParent, \"scroll\", onScroll, {\n            passive: true,\n            capture: true\n          });\n        });\n        return () => {\n          cleanups.forEach((fn) => fn?.());\n        };\n      },\n      trackStore: ({ prop, send }) => {\n        let cleanup;\n        queueMicrotask(() => {\n          cleanup = subscribe(store, () => {\n            if (store.id !== prop(\"id\")) {\n              send({ type: \"close\", src: \"id.change\" });\n            }\n          });\n        });\n        return () => cleanup?.();\n      },\n      trackEscapeKey: ({ send, prop }) => {\n        if (!prop(\"closeOnEscape\")) return;\n        const onKeyDown = (event) => {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Escape\") return;\n          event.stopPropagation();\n          send({ type: \"close\", src: \"keydown.escape\" });\n        };\n        return addDomEvent(document, \"keydown\", onKeyDown, true);\n      },\n      waitForOpenDelay: ({ send, prop }) => {\n        const id = setTimeout(() => {\n          send({ type: \"after.openDelay\" });\n        }, prop(\"openDelay\"));\n        return () => clearTimeout(id);\n      },\n      waitForCloseDelay: ({ send, prop }) => {\n        const id = setTimeout(() => {\n          send({ type: \"after.closeDelay\" });\n        }, prop(\"closeDelay\"));\n        return () => clearTimeout(id);\n      }\n    }\n  }\n});\nvar props = createProps()([\n  \"aria-label\",\n  \"closeDelay\",\n  \"closeOnEscape\",\n  \"closeOnPointerDown\",\n  \"closeOnScroll\",\n  \"closeOnClick\",\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"interactive\",\n  \"onOpenChange\",\n  \"defaultOpen\",\n  \"open\",\n  \"openDelay\",\n  \"positioning\"\n]);\nvar splitProps = createSplitProps(props);\n\nexport { anatomy, connect, machine, props, splitProps };\n"],
  "mappings": "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",
  "names": []
}
